#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    goalpot,        sensorPotentiometer)
#pragma config(Sensor, in2,    conepot,        sensorPotentiometer)
#pragma config(Sensor, in3,    intakepot,      sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           BL,            tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           barL,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           goalL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           goalR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           barR,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          BR,            tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
// Two Controller: ex. "vexRt[Btn5DXmtr2]"
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// SENSOR DEFINITIONS
#define GOALMIN 800  // mobile goal 4-bar
#define GOALMAX 2550

#define BARMAX 3200  // lift
#define BARMIN 1400

#define INTAKETHRESH 1600
//////////////////////
// GLOBAL VARIABLES///
//////////////////////
int driveMin  = 25; //defining joystick dead space

int PIDon[6] = {0,0,0,0,0,0}; // 0:driveL 1:drive 2:turn 3:mobilegoal 4:cone-bar 5:lift
float target[6] = {0,0,0,0,0,0};
int motorMin[6] = {20,20,20,20,20,30};  //defining dead space for motors
float kP[6] = {0.2,0.2,0.1,0.05,0.09,0.9};
float kI[6] = {0.0,0.0,0.0,0.0,0.0,0.0};
float kD[6] = {0.0,0.0,0.0,0.0,0.0,0.0};

int dT = 50;  // ms delay
int dTplayback = 10;

float motorOut[6] = {0,0,0,0,0,0};
//Record/Playback
int L[800];
int R[800];
int T[200];
int B[200];
int In[150];
int DPID[75];
int posL = 0;
int posR = 0;
int posT = 0;
int posB = 0;
int posI = 0;
int posDPID = 0;

// 0:driveL 1:driveR 2:turn 3:mobilegoal 4:cone-bar 5:lift
//encoder: 392 for turbo, 627.2 for torque
///////////
// TASKS///
///////////

task PID()  // 0:driveL 1:drive 2:turn 3:mobilegoal 4:cone-bar 5:lift
// 0:integrated 1:integrated 2:gyro 3:pot 4:pot 5:integrated
{ int sensor[6] = {0,0,0,0,0,0};
    int totalError[6] = {0,0,0,0,0,0};
    float lastError[6] = {0,0,0,0,0,0};
    float dError[6] = {0,0,0,0,0,0};
    float error[6] = {0,0,0,0,0,0};
    while(true)
    { //Sensors
        if(PIDon[3]){sensor[3]=SensorValue(goalpot);}
        if(PIDon[4]){sensor[4]=SensorValue(conepot);}
        //P
        for(int i=0;i<6;i++)
        {error[i]=target[i]-sensor[i];}
        //I
        for(int i=0;i<6;i++)
        {totalError[i]+=error[i];}
        //D
        for(int i=0;i<6;i++)
        {dError[i]=lastError[i]-error[i];}
        //Motor Output

        motorOut[3]=kP[3]*error[3]+kI[3]*totalError[3]+kD[3]*dError[3];
        if(PIDon[3]&&fabs(motorOut[3])>motorMin[3])motor[goalL]=motor[goalR]=-motorOut[3];  //Mobile Goal Holder
        else if(PIDon[3]) motor[goalL]=motor[goalR]=0;

        motorOut[4]=kP[4]*error[4]+kI[4]*totalError[4]+kD[4]*dError[4];
        if(PIDon[4]&&fabs(motorOut[4])>motorMin[4])motor[barL]=motor[barR]=motorOut[4];  //Cone Bar
        else if(PIDon[4]) motor[barL]=motor[barR]=0;
        //Last Error
        for(int i=0;i<6;i++)
        {lastError[i]=error[i];}
        delay(dT);
    }//end of infinite loop
}//end of PID task


////INTAKE TOGGLE////
task intaketoggle()
{     int intakeon = 0;
	while(true){
		if(vexRT[Btn7D]==1){

		if(intakeon) {intakeon=0; motor[intake]=-100;//close
				delay(500); motor[intake]=-30; //close briefly
			if(SensorValue(intakepot)<INTAKETHRESH){motor[intake]=-8;}	//if closes far (not on goal) set to 0
				}

				else {intakeon=1; motor[intake]=127; //opening
					delay(400); motor[intake]=15;}
		}

	}//end of infinite loop
}//end of task

///RECORD///

task record()
{  while(true){if(vexRT[Btn8D]==1){
		posL=0; posR=0; posT=0; posB=0; posI=0; posDPID=0;

		for(int j=0;j<699;j++){L[j]=0;}	//Clear arrays
		for(int j=0;j<699;j++){R[j]=0;}
		for(int j=0;j<199;j++){T[j]=0;}
		for(int j=0;j<199;j++){B[j]=0;}
		for(int j=0;j<149;j++){In[j]=0;}
		int t=0;
  while(true) {

      if(fabs(motor[BL]-L[posL])>=10){L[posL+2]=motor[BL]; L[posL+3]=t; posL+=2;}//if difference in motor out is big
      if(fabs(motor[BR]-R[posR])>=10){R[posR+2]=motor[BR]; R[posR+3]=t; posR+=2;}//enough, make new entry for pwr
      if(fabs(motor[barL]-T[posT])>50){T[posT+2]=motor[barL]; T[posT+3]=t; posT+=2;}//and time and move pos var
      if(fabs(motor[goalL]-B[posB])>10){B[posB+2]=motor[goalL]; B[posB+3]=t; posB+=2;}//forward two, evens pwr, odds time
      if(fabs(motor[intake]-In[posI])>10){In[posI+2]=motor[intake]; In[posI+3]=t; posI+=2;}

      if(fabs(L[posL])<15&&fabs(R[posR])<15){DPID[posDPID]=nMotorEncoder[BL]; DPID[posDPID+1]=nMotorEncoder[BR];}
      //if the motor output for both drive motors is low enough, save encoder position
				t+=dTplayback;
      if(vexRT[Btn8U]==1){break;}//break out of loop
		delay(dTplayback);
  } //end of for loop

  }delay(10);}//end of while and if
}//end of task

/////////////
//PRE-AUTON//
/////////////
void pre_auton(){
//PASTE ARRAYS//


}

////////////
///AUTON////
////////////
task autonomous()
{ stopTask(intaketoggle);
	posL=posR=posT=posB=posL=posI=0;//reset position
	startTask(PID);
	PIDon[3]=PIDon[4]=0;//turning off pid
    ///Main//
//PLAYBACK
	int t=0; //time marker
	int top=0; //temp motor output holder
	int toptog=1;
while(true)
{
    if(L[posL+1]==t){motor[BL]=motor[FL]=L[posL]; posL+=2;}//playing back arrays
    if(R[posR+1]==t){motor[BR]=motor[FR]=R[posR]; posR+=2;}
    if(T[posT+1]==t){motor[barL]=motor[barR]=top=T[posT]; posT+=2;}
    if(B[posB+1]==t){motor[goalL]=motor[goalR]=B[posB]; posB+=2;}
    if(In[posI+1]==t){motor[intake]=In[posI]; posI+=2;}
		t+=dTplayback;
    delay(dTplayback);
    if(t>59800){break;}
    //Additions
		if(fabs(top)>100){PIDon[4]=0; motor[barL]=motor[barR]=top; toptog=1;}//pid overridden if 127,-127

		else if(toptog){PIDon[4]=1; target[4]=SensorValue(conepot)-sgn(T[posT-2])*420; //PID
			if(SensorValue(conepot)<1400){target[4]=940;} toptog=0;}

		if(SensorValue(conepot)<1400&&top<-100){top=0;}//limit on bottom to prevent clicking
    //End of additions
} //end of for
//End with all motors 0
motor[FL]=motor[FR]=motor[BL]=motor[BR]=0;
motor[intake]=motor[barL]=motor[barR]=0;
motor[goalL]=motor[goalR]=0;
    //End
}

///////////////////
////USER CONTROL///
///////////////////

task usercontrol()
{ // 0:driveL 1:drive 2:turn 3:mobilegoal 4:cone-bar 5:lift
    //Variables
    PIDon[0]=PIDon[1]=PIDon[3]=PIDon[4]=0;  // Turn drive PID off
    float conedir = 0;
    float goaldir = 0;
    //Tasks
    startTask(PID);
    startTask(record);
    startTask(intaketoggle);
    //LOOP
    while (true)
    {		delay(dTplayback);
        //Drive
        if(fabs(vexRT[Ch3])>driveMin) {motor[BL]=motor[FL]=10*ceil(vexRT[Ch3]/10);}
        else {motor[BL]=motor[FL]=0;}
        if(fabs(vexRT[Ch2])>driveMin) {motor[BR]=motor[FR]=10*ceil(vexRT[Ch2]/10);}
        else {motor[BR]=motor[FR]=0;}
        //Mobile Goal
        if(SensorValue(goalpot)>GOALMIN&&vexRT[Btn6U]) {PIDon[3]=0; motor[goalL]=motor[goalR]=127; goaldir=1.2;}  //unaffected by stack
        else if(SensorValue(goalpot)<GOALMAX&&vexRT[Btn6D]) {PIDon[3]=0; motor[goalL]=motor[goalR]=-127; goaldir=-1;}
        else if(PIDon[3]==0) {motor[goalL]=motor[goalR]=0; PIDon[3]=1; target[3]=SensorValue(goalpot)-220*goaldir; goaldir=0;}
        //Manual ConeBar
        if(SensorValue(conepot)>BARMIN&&vexRT[Btn5D]) {PIDon[4]=0; motor[barL]=motor[barR]=-127; conedir=7;}  //button press
        else if(SensorValue(conepot)<BARMAX&&vexRT[Btn5U]) {PIDon[4]=0; motor[barL]=motor[barR]=127; conedir=-7;}
        else if(PIDon[4]==0){motor[barL]=motor[barR]=0; PIDon[4]=1; target[4]=SensorValue(conepot)-60*conedir; conedir=0;
        	if(SensorValue(conepot)<1400){target[4]=940;}}

        ///////////////////////
        //Return Array values//
        //////////////////////
        if(vexRT[Btn7R]==1){string foo;
        clearDebugStream();
        	//L
        	writeDebugStreamLine("L[700]={");
        	for(int i=0;i<700;i++){foo=L[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
        	writeDebugStreamLine("};");
        }//end of array value out
        if(vexRT[Btn8L]==1){string foo;
        clearDebugStream();
        	//R
        	writeDebugStreamLine("R[700]={");
        	for(int i=0;i<700;i++){foo=R[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
        	writeDebugStreamLine("};");
        }//end of array value out
        if(vexRT[Btn8R]==1){string foo;
        	clearDebugStream();
        	//T
        	writeDebugStreamLine("T[200]={");
        	for(int i=0;i<200;i++){foo=T[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
        	writeDebugStreamLine("};");
        	//B
        	writeDebugStreamLine("B[200]={");
        	for(int i=0;i<200;i++){foo=B[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
        	writeDebugStreamLine("};");
        	//I
        	writeDebugStreamLine("In[150]={");
        	for(int i=0;i<150;i++){foo=In[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
        	writeDebugStreamLine("};");
        }//end of array value conditional

    }//end of infinite loop

}//end of
