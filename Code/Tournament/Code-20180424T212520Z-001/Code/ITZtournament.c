#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    goalpot,        sensorPotentiometer)
#pragma config(Sensor, in2,    conepot,        sensorPotentiometer)
#pragma config(Sensor, in3,    expander,       sensorAnalog)
#pragma config(Sensor, in4,    gyro,           sensorGyro)
#pragma config(Sensor, in5,    autonSelection, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  liftE,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  right,          sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  left,           sensorQuadEncoder)
#pragma config(Motor,  port1,           goalR,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           liftR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           conebar,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           liftL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          goalL,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
// Two Controller: ex. "vexRt[Btn5DXmtr2]"\
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// SENSOR DEFINITIONS
#define GOALMIN 310  // mobile goal 4-bar
#define GOALMAX 2280

#define CONEBARIN 1865  // cone intake 4-bar
#define CONEBAROUT 3498

#define LIFTIDLE -60  //height right above cones
#define LIFTPRELOAD -120  //height of preloads


//////////////////////
///GLOBAL VARIABLES///
//////////////////////
int turnSign=1;//for left and right autons
int cones=0;//currently how man stacked
int driveMin  = 20; //defining joystick dead space
int stall=1;//"0" means stalling
bool stackon = false;

int fieldOffset=0;
////////////////
//STACK ARRAYS//
////////////////

//PRELOADS
int cheight[19]= {0,0,0,0,140,190,224,253,324,350,375,414,465,487,523,558,573,590,630};
//1 2 3 4  5  6   7   8   9   10  11  12  13  14  15  16  17  18  19

//FIELDING
int fheight[19]= {50,60,70,89,135,185,219,248,319,345,375,415,455,480,523,554,570,575,615};
                 //1  2  3  4  5   6   7   8   9   10  11  12  13  14  15  16  17  18  19



//PID Variables
int PIDon[6] = {0,0,0,0,0,0}; // 0:driveL 1:driveR 2:turn 3:mobilegoal 4:cone-bar 5:lift
float target[6] = {0,0,0,0,0,0};
int motorMin[6] = {20,20,20,20,20,17};  //defining dead space for motors
float kP[6] = {0.23,0.23,0.1,0.2,0.26,0.6};
float kI[6] = {0.04,0.04,0.0,0.0,0.0,0.0};
float kD[6] = {0.07,0.07,0.0,0.0,0.0,0.1};
float motorOut[6] = {0,0,0,0,0,0};
int totalError[6];

int dT = 25;  // ms delay`



//Include
#include "functions.h"
#include "antistall.h"
#include "4Bar.h"
#include "stack.h"




///////////
/// PID////
///////////
task PID()  // 0:driveL 1:drive 2:N/A  3:mobilegoal 4:cone-bar 5:lift

{ int sensor[6];
	float lastError[6];
	float dError[6];
	float error[6];
	while(true)
	{ //Sensors
		if(PIDon[0]){sensor[0]=SensorValue(left);}
		if(PIDon[1]){sensor[1]=SensorValue(right);}
		if(PIDon[3]){sensor[3]=SensorValue(goalpot);}
		if(PIDon[5]){sensor[5]=SensorValue(liftE);}
		//P
		for(int i=0;i<6;i++)
		{error[i]=target[i]-sensor[i];}
		//I
		for(int i=0;i<6;i++)
		{if(fabs(error[i])<100){totalError[i]+=error[i];}}
		//D
		for(int i=0;i<6;i++)
		{dError[i]=lastError[i]-error[i];}
		//Motor Output
		motorOut[0]=(kP[0]*error[0]+kI[0]*totalError[0]+kD[0]*dError[0])*stall;
		if(PIDon[0]&&fabs(motorOut[0])>motorMin[0])motor[BL]=motor[FL]=motorOut[0];  //Left Drive
		else if(PIDon[0]) motor[BL]=motor[FL]=0;

		motorOut[1]=(kP[1]*error[1]+kI[1]*totalError[1]+kD[1]*dError[1])*stall;
		if(PIDon[1]&&fabs(motorOut[1])>motorMin[1])motor[BR]=motor[FR]=motorOut[1];  //Right Drive
		else if(PIDon[1]) motor[BR]=motor[FR]=0;

		motorOut[3]=kP[3]*error[3]+kI[3]*totalError[3]+kD[3]*dError[3];
		if(PIDon[3]&&fabs(motorOut[3])>motorMin[3])motor[goalL]=motor[goalR]=-motorOut[3];  //Mobile Goal Holder
		else if(PIDon[3]) motor[goalL]=motor[goalR]=0;

		motorOut[5]=-(kP[5]*error[5]+kI[5]*totalError[5]+kD[5]*dError[5]);
		if(PIDon[5]&&fabs(motorOut[5])>motorMin[5])motor[liftL]=motor[liftR]=motorOut[5];  //Lift
		else if(PIDon[5]) motor[liftL]=motor[liftR]=0;

		//Last Error
		for(int i=0;i<6;i++)
		{lastError[i]=error[i];}
		delay(dT);
	}//end of infinite loop
}//end of PID task



///////
//LCD//
///////
#include "ITZLCD.h"

/////////////
//PRE-AUTON//
/////////////
void pre_auton()
{
	resetEncoders();
}

////////////
///AUTON////
////////////
task autonomous()
{    // Start Tasks
	startTask(antistall);
	startTask(LCD);

	//Defualt (left)
	if(SensorValue(autonSelection)<1100){selectedAuton=2; autonSide=false;}//1st

	//Backup Backup (center)
//if (SensorValue(autonSelection)>1100&&SensorValue(autonSelection)<2900){ selectedAuton=0; autonSide=true;}//2nd on sationary

	//Backup (right)
	if(SensorValue(autonSelection)>2900) {selectedAuton=2; autonSide=true;}//20 pnt from center




	target[0]=target[1]=target[3]=target[4]=0;
	PIDon[4]=1;
	resetEncoders();
	startTask(PID);
	startTask(fourBarNORforbar);

	if(autonSide) turnSign = -1;//right
	else					turnSign = 1;//left

	/*
	BUILD AUTON:
	Left/Right
	Fielding 4 cones in 20
	Preloads in 20
	Preloads in 5
	Stationary, cones in 5 point
	Defensive, stat and block
	*/

	if((SensorValue[expander]/275.0)>4.9){//if power expander plugged in
		switch (selectedAuton){
		case 0:
#include "4ConeField.h"//default 20 pnt
			break;

		case 1:
#include "20Preloads.h"//don't use
			break;

		case 2:
#include "5Preloads.h"//good loader auton
			break;

		case 3:
#include "StatDefensive.h"//Fuzzy auton for 20 points
			break;

		case 4:
#include "StatField.h"//Other fuzzy auton
			break;

		case 5:
#include "6cone5pnt.h"//unclear (outdated?)
			break;

		case 6:
#include "4cone5point.h" //torque (fielding)
			break;

		default: break;

		}//end of switch

	}
}



///////////////////
////USER CONTROL///
///////////////////

task usercontrol()
{ // 0:driveL 1:drive 2:turn 3:mobilegoal 4:cone-bar 5:lift
	//Variables
	PIDon[0]=PIDon[1]=PIDon[3]=PIDon[4]=PIDon[5]=0;  // Turn drive PID off
	stackon = false;
	float goaldir = 0;//for setting goal PID
	int activeBtn=0;//for toggle on partner controller
	int statMult=1;//stationary destack multiplier
	int statToggle=1;//stationary destack toggle value
	//Tasks
	startTask(stack);
	startTask(fourBarNORforbar);
	startTask(PID);
	startTask(LCD);
	stopTask(antistall);

	//LOOP
	while (true)
	{

		//DRIVE
		if(fabs(vexRT[Ch3])>driveMin&&fabs(vexRT[Ch3])<120) {motor[BL]=motor[FL]=vexRT[Ch3];}  //unaffected by stack
		else if(fabs(vexRT[Ch3])>120){motor[BL]=motor[FL]=127*sgn(vexRT[Ch3]);}
		else {motor[BL]=motor[FL]=0;}

		if(fabs(vexRT[Ch2])>driveMin&&fabs(vexRT[Ch2])<120) {motor[BR]=motor[FR]=vexRT[Ch2];}  //unaffected by stack
		else if(fabs(vexRT[Ch2])>120){motor[BR]=motor[FR]=127*sgn(vexRT[Ch2]);}
		else {motor[BR]=motor[FR]=0;}

		//MOBILE GOAL
		if(SensorValue(goalpot)>GOALMIN&&(vexRT[Btn6U]||vexRT[Btn5UXmtr2])) //bring in
		{PIDon[3]=0; motor[goalL]=motor[goalR]=127; goaldir=1.2;}
		else if(SensorValue(goalpot)<GOALMAX&&(vexRT[Btn6D]||vexRT[Btn5DXmtr2])) //put out
		{PIDon[3]=0; motor[goalL]=motor[goalR]=-127; goaldir=-1;}

		else if(PIDon[3]==0) //setting PID targets
		{motor[goalL]=motor[goalR]=0; PIDon[3]=1; target[3]=SensorValue(goalpot)-220*goaldir; goaldir=0;
			if(SensorValue(goalpot)>GOALMAX-450){target[3]=GOALMAX+140;}
			if(SensorValue(goalpot)<GOALMIN+560){target[3]=GOALMIN-200;}  }


		// LIFT
		if(vexRT(Btn5U)==1){PIDon[5]=0; motor[liftL]=motor[liftR]=127;//up
			if(SensorValue(conepot)<2500&&vexRT[Btn8D]==0&&statMult==1&&(vexRT[Btn6UXmtr2]==0&&vexRT[Btn6DXmtr2]==0)){Intake("Out"); }
			if(SensorValue(conepot)>2500&&vexRT[Btn8D]==0&&statMult==-1&&(vexRT[Btn6UXmtr2]==0&&vexRT[Btn6DXmtr2]==0)){Intake("Out"); }	}

		else if(vexRT(Btn5D)==1&&stackon==false){PIDon[5]=0; motor[liftL]=motor[liftR]=-127;//down
			if(SensorValue(conepot)>2500&&vexRT[Btn8D]==0&&statMult==1&&(vexRT[Btn6UXmtr2]==0&&vexRT[Btn6DXmtr2]==0)){Intake("In"); }
			if(SensorValue(conepot)<2500&&vexRT[Btn8D]==0&&statMult==-1&&(vexRT[Btn6UXmtr2]==0&&vexRT[Btn6DXmtr2]==0)){Intake("In"); }	}


		else if(vexRT[Ch3Xmtr2]>40){PIDon[5]=0; motor[liftL]=motor[liftR]=vexRT[Ch3Xmtr2];//partner lift controls
			if(SensorValue(conepot)<2500&&vexRT[Btn8D]==0&&statMult==1&&(vexRT[Btn6UXmtr2]==0&&vexRT[Btn6DXmtr2]==0)){Intake("Out"); }
			if(SensorValue(conepot)>2500&&vexRT[Btn8D]==0&&statMult==-1&&(vexRT[Btn6UXmtr2]==0&&vexRT[Btn6DXmtr2]==0)){Intake("Out"); }	 }

		else if(vexRT[Ch3Xmtr2]<-40){PIDon[5]=0; motor[liftL]=motor[liftR]=vexRT[Ch3Xmtr2];
			if(SensorValue(conepot)>2500&&vexRT[Btn8D]==0&&statMult==1&&(vexRT[Btn6UXmtr2]==0&&vexRT[Btn6DXmtr2]==0)){Intake("In"); }
			if(SensorValue(conepot)<2500&&vexRT[Btn8D]==0&&statMult==-1&&(vexRT[Btn6UXmtr2]==0&&vexRT[Btn6DXmtr2]==0)){Intake("In"); }	 }


		else if (stackon==false) {motor[liftL]=motor[liftR]= 0;} 	//default zero



		//INTAKE
		if(vexRT[Btn8U]||vexRT[Btn6UXmtr2]) {Intake("Out");}
		else if(vexRT[Btn8D]||vexRT[Btn6DXmtr2]) {Intake("In");}
		else if(stackon==false&&vexRT(Btn5D)==0&&vexRT(Btn5U)==0&&fabs(vexRT[Ch3Xmtr2])<40)
		{Intake("Stop");}

		//Manual ConeBar
		if(SensorValue(conepot)>CONEBARIN+120&&vexRT[Btn7U]) {PIDon[4]=0; motor[conebar]=127; }  //down
		else if(SensorValue(conepot)<CONEBAROUT-140&&vexRT[Btn7D]) {PIDon[4]=0; motor[conebar]=-127; }

		else if (SensorValue(conepot)>CONEBARIN+120&&vexRT[Ch2Xmtr2]>35) {PIDon[4]=0; motor[conebar]=vexRT[Ch2Xmtr2]; }
		else if (SensorValue(conepot)<CONEBAROUT-140&&vexRT[Ch2Xmtr2]<-35) {PIDon[4]=0; motor[conebar]=vexRT[Ch2Xmtr2]; }

		else if(stackon==false&&PIDon[4]==0){PIDon[4]=1;
			if(SensorValue(conepot)>CONEBAROUT-650){target[4]=CONEBAROUT;}
			else{target[4]=CONEBARIN;}}


		//Reseting Encoders
		if(vexRT[Btn8L]==1){resetEncoders();}
		if(SensorValue(goalpot)>1100){cones=0;}

		//Stack Function Counter
		if(vexRT[Btn8LXmtr2]&&activeBtn==1){if(cones<19){cones++;} activeBtn=0;}//counting cones
		else if(vexRT[Btn8DXmtr2]&&activeBtn==1){if(cones>0){cones--;} activeBtn=0;}
		else if(vexRT[Btn8RXmtr2]&&activeBtn==1){cones=0; activeBtn=0;}
		if(vexRT[Btn8RXmtr2]==0&&vexRT[Btn8LXmtr2]==0&&vexRT[Btn8DXmtr2]==0){activeBtn=1;}

		if(vexRT[Btn7RXmtr2]==1&&statToggle==1){statMult=-statMult; statToggle=0;}//flip intake movements
		if(vexRT[Btn7RXmtr2]==0){statToggle=1;}



	}//end of infinite loop

}//end of end of usercontrol()
