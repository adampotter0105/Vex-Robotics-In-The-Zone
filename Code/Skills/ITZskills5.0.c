#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    goalpot,        sensorPotentiometer)
#pragma config(Sensor, in2,    pot,            sensorPotentiometer)
#pragma config(Sensor, in4,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           goalR,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           BR,            tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           barR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           barL,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BL,            tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          goalL,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
// Partner Controller: ex. "vexRt[Btn5DXmtr2]"
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*Documentation for Tasks and Functions
Task: PID()
	controls bar and goal intake, controlled by "target" and "targetgoal"
Task: Autobar()
	changes between 4 states(including starting) during auton
Task: Move()
	if "go" or "turn" are set not zero, pid pulls drive to target
	untile reaches deadzone, then brakes
Function: Forward()
	moves forward or backwards with float argument in feet
Function: GyTurn()
	turns with argument int degrees clockwise positive
Function: Goal()
	moves goal intake with argument "In" or "Out"
Function: Claw()
	moves bar and claw between states with arguments "Out", "Grab", "Place"
Function: Wait()
	by default, it waits untile movement is complete ("go" or "turn" = 0)
	with argument in feet progress, it breaks when forward() is "progress" into movement
*/
//////////////////////
// GLOBAL VARIABLES///
//////////////////////

#define IN 3500
#define MID 2300
#define OUT 20

#define GOALIN 1780
#define GOALOUT 3830

#include "TasksNFunctions.h"

///////////
///Auton///
///////////
void pre_auton(){}

task autonomous()
{ stopTask(PID);
	startTask(autobar);
	startTask(move);

#include "skillsAuton.h"
}



///BAR TASK/// for usercontrol
task bar()
{ int state=0;
	//Starting
	motor[intake]=100; target=MID;
	delay(200); motor[intake]=40;

	while(true){

		if (vexRT[Btn8D]==1||vexRT[Btn8DXmtr2])
		{state++;
			if(state>3){state=1;}
			//out
			if(state==1){pidon=false; motor[barL]=motor[barR]=-80;
				motor[intake]=-120; delay(350); motor[barL]=motor[barR]=0; motor[intake]=-10;}
			//grab
			if(state==2){motor[intake]=120; delay(170);
				max = 100; target=MID; pidon=true; delay(200); motor[intake]=35;}
			//place
			if(state==3){max = 65; target=IN; pidon=true;
				 delay(500); pidon=false; motor[barL]=motor[barR]=0; motor[intake]=-120; delay(150);
				 pidon=true; target=MID; delay(200); motor[intake]=0; }
	}


	delay(50);
}//end of loop
}//end of task


///////////////////
////USER CONTROL///
///////////////////

task usercontrol()
{ //Tasks

	stopTask(autobar);
	stopTask(move);

	startTask(PID); pidongoal=false;
	startTask(bar);


	//LOOP
	while (true)
	{   //DELAY
		delay(50);

		//Drive
		if(fabs(vexRT[Ch3])>20){motor[BL]=motor[FL]=vexRT[Ch3];}//L
			else{motor[FL]=motor[BL]=0;}
		if(fabs(vexRT[Ch2])>20){motor[BR]=motor[FR]=vexRT[Ch2];}//R
			else{motor[FR]=motor[BR]=0;}

		//Mobile Goal
		if(vexRT[Btn6U]) { motor[goalL]=motor[goalR]=127;}
		else if(vexRT[Btn6D]) { motor[goalL]=motor[goalR]=-127;}
		else { motor[goalL]=motor[goalR]=0;}


	}//end of infinite loop
}//end of
