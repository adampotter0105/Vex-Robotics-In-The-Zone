#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    goalpot,        sensorPotentiometer)
#pragma config(Sensor, in2,    conepot,        sensorPotentiometer)
#pragma config(Sensor, in3,    intakepot,      sensorPotentiometer)
#pragma config(Sensor, in4,    yaw,            sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           BL,            tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           barL,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           goalL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intake2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           goalR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           barR,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          BR,            tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
// Two Controller: ex. "vexRt[Btn5DXmtr2]"
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// SENSOR DEFINITIONS
#define GOALMIN 800  // mobile goal 4-bar
#define GOALMAX 2550

#define INTAKEOPEN 1400 //max open
#define INTAKETHRESH1 2300 //between closed and holding cone

//BAR Sections   [target, low, high]
#define BARMIN 1330 // physical limits
#define BARMAX 3800
int barLOW[3] = {1050, 1000, 1450};
int barMID[3] = {2150, 1450, 2200};
int barHI[3] = {3200, 2200, 4001};
//////////////////////
// GLOBAL VARIABLES///
//////////////////////

int PIDon[2]={0,1}; // 0:driveL 1:drive 2:turn 3:mobilegoal 4:cone-bar 5:lift
float target[3]= {0,0, 3200};
int totalError[3];
float error[3];
int motorMin = 20;  //defining dead space for motors
const float kP[2] = {0.48,0.12};
const float kI[2] = {0,0}; //0.002?
const float kD[2] = {0,0};

int dT = 50;

float tickDeg=3.81; //ticks/degree

int intakeon = 0;
int intakepos= 0;
int bottompos = 0;

float motorOut;



////PID////

task PID()

{ int sensor[3];
	float lastError[3];
	float dError[3];
	while(true)
	{ //Sensors
		if(PIDon[0]){sensor[0]=nMotorEncoder(BL);}//L
		if(PIDon[0]){sensor[1]=nMotorEncoder(BR);}//R
		if(PIDon[1]){sensor[2]=SensorValue(conepot);}//bar
		//P
		error[0]=target[0]-sensor[0];
		error[1]=target[1]-sensor[1];
		error[2]=target[2]-sensor[2];
		//I
		totalError[0]+=error[0];
		totalError[1]+=error[1];
		totalError[2]+=error[2];
		//D
		dError[0]=lastError[0]-error[0];
		dError[1]=lastError[1]-error[1];
		dError[2]=lastError[2]-error[2];
		//Motor Output
		motorOut=kP[1]*error[2]+kI[1]*totalError[2]+kD[1]*dError[2];
		if(fabs(motorOut)>100)  {motorOut=sgn(motorOut)*100;}//round down to 100
		if(PIDon[1]&&fabs(motorOut)>motorMin){motor[barL]=motor[barR]=motorOut;}  //Cone Bar
		else if(PIDon[1]) {motor[barL]=motor[barR]=0;}

		if(PIDon[0]){ motor[BL]=motor[FL]=(kP[0]*error[0]+kI[0]*totalError[0]+kD[0]*dError[0]);
									motor[BR]=motor[FR]=(kP[0]*error[1]+kI[0]*totalError[1]+kD[0]*dError[1]);  }
		//Last Error
		lastError[0]=error[0];
		lastError[1]=error[1];
		lastError[2]=error[2];
		delay(dT);
	}//end of infinite loop
}//end of PID task




////INTAKE TOGGLE////
task intaketoggle()
{
	while(true){
		if(vexRT[Btn7D]==1 || vexRT[Btn7DXmtr2]==1){ //if button pressed

			if(intakeon) {intakeon=0; //closing
				motor[intake]=motor[intake2]=-120; delay(400);
				if(SensorValue(intakepot)>INTAKETHRESH1)
				{motor[intake]=motor[intake2]=-30; delay(250); motor[intake]=motor[intake2]=10;} //closes on nothing
				else {motor[intake]=motor[intake2]=-30;} //closes on cone

			}

			else {intakeon=1;
				motor[intake]=motor[intake2]=120; delay(350);//opening
				motor[intake]=motor[intake2]=30; delay(200);
				motor[intake]=motor[intake2]=0;}
		}
		delay(50);
	}//end of infinite loop
}//end of task


//FUNCTIONS///

void forward( float rot, int override=0) // forward
{if(override==0){ target[0]+=rot*627; target[1]+=rot*627; delay(50);}
	else if(override){ target[0]=nMotorEncoder(BL)+rot*627; target[1]=nMotorEncoder(BR)+rot*627; delay(50);}}

void turn( float deg) //turning
{ target[0]+=deg*tickDeg; target[1]-=deg*tickDeg; delay(50);}

void top(string *pos) //Top bar
{
if (*pos=="up"){target[2]=barHI[0];}
if (*pos=="mid"){target[2]=barMID[0];}
if (*pos=="down"){target[2]=barLOW[0];}
}

void bottom(string *pos)//bottom bar
{
if (*pos=="up"){bottompos=0;}
if (*pos=="down"){bottompos=1;}
}

void claw(string *pos)//claw
{
if (*pos=="open"){intakepos=0;}
if (*pos=="close"){intakepos=1;}
}

void wait(int maxerror=50, int timeout=3000)//wait for pid
{ for (int i=0; i<(timeout/10); i++){delay(10); if(fabs(error[0])+fabs(error[1])<maxerror*2){break; }
	delay(40);}
}

void throw()
{ top("mid");//lift
	forward(0.65);//forward
	wait( );
	turn(-20);//turn
	wait( );
	forward(2);//
	delay(890);
	claw("open");
	top("up");
	delay(300);
	bottom("down");
	delay(1150);
	forward(-0.45,1);
	delay(500);
	bottom("up");
	wait(90, 5000);
	}

	void throw2()
{ top("mid");//lift
	forward(0.65);//forward
	wait( );
	turn(-28);//turn
	wait( );
	forward(1.95);//
	delay(710);
	claw("open");
	top("up");
	delay(300);
	bottom("down");
	delay(1150);
	forward(-0.45,1);
	delay(500);
	bottom("up");
	wait(90, 5000);
	}

//Tasks//
task intakeclaw(){ int last=0; while(1){if(last!=intakepos){last=intakepos;
	if(intakepos==1){motor[intake]=motor[intake2]=-127; delay(350); motor[intake]=motor[intake2]=-30;}
	if(intakepos==0){motor[intake]=motor[intake2]=127; delay(350); motor[intake]=motor[intake2]=30;}
	}}}
task bottombar(){int last=0; while(1){if(last!=bottompos){last=bottompos;
	if(bottompos==1){motor[goalL]=motor[goalR]=-127; delay(850); motor[goalL]=motor[goalR]=-30;}
	if(bottompos==0){motor[goalL]=motor[goalR]=127; delay(850); motor[goalL]=motor[goalR]=30;} }}}

/////////////
//PRE-AUTON//
/////////////
void pre_auton(){
	//PASTE ARRAYS//

}




/////////////
///PLAYBACK//
/////////////


task autonomous()
{ stopTask(intaketoggle);
	startTask(intakeclaw);
	startTask(bottombar);
	resetMotorEncoder(BL);
	resetMotorEncoder(BR);
	startTask(PID);
	PIDon[0]=1;
	target[0]=target[1]=0;


	//PID Auton//

	//Drop Cone
	top("up"); claw("close"); bottom("down"); //start
	delay(500);
	top("up"); forward(1.073);//forward to first goal
	wait( );
	delay(100);
	top("down");
	delay(550);
	claw("open"); top("mid");
	delay(200);
	top("up");
	delay(600);//drop cone
	forward(0.5);
	//Pickup 1st goal
	delay(700);
	bottom("up"); claw("close");//move forward
	wait( );
	delay(800);
	top("down");//bring down arm
	delay(600);
	//Grabs 2nd Goal
	forward(0.5);
	wait( );
	claw("open"); forward(1.45); //move to goal
	delay(1000); claw("close");
	wait();

	throw();//THROW

	//Turn to next goal
	turn(-87); wait( );
	forward(0.91); bottom("down");wait( );
	turn(-93);  wait( );
	//Picked up 3rd goal
	forward(1.36); wait( );
	bottom("up");
	delay(600);
	// grab 4th goal
	top("down");
	claw("open");
	delay(850);
	turn(-14); wait();
	forward(1.42); wait( );
	claw("close");
	delay(300);
	forward(0.85);
	wait();

	throw2(); //Throw

	//Turning Towards 5th goal
	turn(-85); wait( );
	forward(1.11); bottom("down");
	top("down"); claw("close");
	wait( );
	turn(-24);
	wait( );
	forward(0.55);
	wait( );
	turn(-29); wait( );
	//Going to pickup goal
	forward(0.65);  wait( );
	top("up");	delay(1000);
	forward(1.3);
	wait();
	bottom("up"); delay(600);
	//Back Out
	forward(-2); wait( );
	turn(47); wait( );//turn back toward
  forward(-0.8); wait(50, 400);
	turn(88); wait();
	forward(0.3); wait(50, 300);
	bottom("down"); //places goal
	delay(1100);
	//Pulls out of 5th goal
	forward(-0.4); bottom("up");  wait( );

	//Turning to 6th goal
	turn(90); wait( );
	forward(2.2); wait( ); delay(300);
	turn(50); wait( );
	bottom("down"); delay(450); forward(1.9); wait( );//forward onto goal
	bottom("up"); delay(700);
	forward(-0.5); top("down"); claw("close");
	wait(); delay(400);

	//Turning to Cone Mess
	turn(32); wait( );
	forward(0.72);  wait( );
	claw("open");
	delay(300);
	turn(18); wait();
	//Grab Last Goal
	motor[intake]=motor[intake2]=-45; delay(55); motor[intake]=motor[intake2]=-5;//weird intake thing
	forward(0.35); wait(); delay(100);
	forward(0.35); wait();
	delay(300);
	claw("close");  delay(500);
	top("mid"); delay(500);
	turn(-40); wait();
	forward(-1.25); wait();
	//Turn to corner
	turn(80); wait();
	forward(3.4); wait(50, 4500);
	turn(-30); wait(); forward(0.4); wait();
	//Drop Goals
	top("down"); delay(400); claw("open");
	delay(600); top("up"); delay(500);
	forward(-0.3); wait();
	turn(-90); wait(); forward(0.4); wait();
	turn(90); wait(); forward(0.4); delay(300);
	bottom("down"); wait(); delay(500); forward(-0.5); delay(200);
	bottom("up");
	//Park
	/*turn(45); wait();
	forward(-2.5); */

	//Instead of park
	turn(90); wait();
	forward(3.1); wait();
	turn(45); wait();
	bottom("down"); delay(500);
	forward(1.5); wait();
	bottom("up"); delay(550);
	forward(-1.4); wait();
	turn(-43); wait();
	forward(-3.1); delay(1000);
	bottom("down");
	wait();
	//Park
	bottom("up"); turn(-45); wait();
	forward(-2.6);

//*/
}

void begin() {
	stopTask(intaketoggle);
	startTask(intakeclaw);
	startTask(bottombar);
	resetMotorEncoder(BL);
	resetMotorEncoder(BR);
	startTask(PID);
	PIDon[0]=1;
	target[0]=target[1]=0;


	//PID Auton//

	//Drop Cone
	top("up"); claw("close"); bottom("down"); //start
	delay(500);
	top("up"); forward(1.14);//forward to first goal
	wait( );
	delay(100);
	top("down");
	delay(450);
	claw("open"); top("mid");
	delay(200);
	top("up");
	delay(600);//drop cone
	forward(0.5);
}




///////////////////
////USER CONTROL///
///////////////////

task usercontrol()
{ //Tasks
	//begin();
	//stopTask(PID);
	intakeon=1;
	startTask(intaketoggle);
	PIDon[0]=0; PIDon[1]=1;
	startTask(PID);
	stopTask(intakeclaw);
	stopTask(bottombar);



	//LOOP
	while (true)
	{   //DELAY
		delay(50);

		//Drive
		motor[BL]=motor[FL]=vexRT[Ch3];//L
		motor[BR]=motor[FR]=vexRT[Ch2];//R

		//Mobile Goal
		if(SensorValue(goalpot)>GOALMIN&&(vexRT[Btn6U]||vexRT[Btn6UXmtr2])) { motor[goalL]=motor[goalR]=127;}  //unaffected by stack
		else if(SensorValue(goalpot)<GOALMAX&&(vexRT[Btn6D]||vexRT[Btn6DXmtr2])) { motor[goalL]=motor[goalR]=-127;}
		else  {if(SensorValue(goalpot)>GOALMAX-250){motor[goalL]=motor[goalR]=-30;}//pulls down bar if close to bottom
			else{motor[goalL]=motor[goalR]=0;}}

		//Manual ConeBar
		if(SensorValue(conepot)>BARMIN&&(vexRT[Btn5DXmtr2]||vexRT[Btn5D])) {PIDon[1]=0; motor[barL]=motor[barR]=-127;}  //button press
		else if(SensorValue(conepot)<BARMAX-500&&(vexRT[Btn5UXmtr2]||vexRT[Btn5U])) {PIDon[1]=0; motor[barL]=motor[barR]=127;}
		else if(PIDon[1]==0){motor[barL]=motor[barR]=0; PIDon[1]=1;
			if(SensorValue(conepot)>barLOW[1]&&SensorValue(conepot)<barLOW[2])    {target[2]=barLOW[0];}//interval 1
			if(SensorValue(conepot)>barMID[1]&&SensorValue(conepot)<barMID[2])    {target[2]=barMID[0];}//interval 2
			if(SensorValue(conepot)>barHI[1]&&SensorValue(conepot)<barHI[2])    {target[2]=barHI[0];}//interval 3
		}

	}//end of infinite loop
}//end of
